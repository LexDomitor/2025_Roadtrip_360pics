<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>360 Sphere Viewer</title>

<style>
html,body { margin:0; height:100%; overflow:hidden; background:#000; font-family:system-ui; }

/* --- NAV BUTTONS (Desktop Hover) --- */
.nav-btn {
  position: fixed;
  top: 50%;
  transform: translateY(-50%);
  width: 60px;
  height: 60px;
  border-radius: 14px;
  display: flex;
  align-items:center;
  justify-content:center;
  font-size: 32px;
  color: white;
  backdrop-filter: blur(12px);
  background: rgba(255,255,255,0.18);
  border: 1px solid rgba(255,255,255,0.25);
  cursor: pointer;
  opacity: 0;
  transition: opacity 0.2s;
  z-index: 20;
}
#nav-left { left: 20px; }
#nav-right { right: 20px; }

body.desktop.hover-left #nav-left,
body.desktop.hover-right #nav-right {
  opacity: 1;
}

/* --- HELP OVERLAY --- */
#helpOverlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.7);
  color: white;
  display: flex;
  align-items:center;
  justify-content:center;
  text-align:center;
  padding:20px;
  z-index: 50;
  font-size: 18px;
  line-height: 1.4;
}

/* --- Viewer --- */
#viewer { width:100%; height:100%; }

/* --- Bottom Frosted Bar --- */
#footerBar {
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 13px;
  color: #d0d0d0;
  backdrop-filter: blur(10px);
  background: rgba(255,255,255,0.1);
  border-top: 1px solid rgba(255,255,255,0.18);
  z-index: 40;
  pointer-events: none; /* makes sure it doesn't block clicks */
}
</style>
</head>

<body>

<!-- Navigation Buttons -->
<div id="nav-left" class="nav-btn">&#10094;</div>
<div id="nav-right" class="nav-btn">&#10095;</div>

<!-- Help Overlay -->
<div id="helpOverlay">
  <div>
    <p><b>Controls</b></p>
    <p>• Drag to rotate the sphere</p>
    <p>• Pinch or mouse wheel to zoom</p>
    <p>• Click or tap left/right edges to switch images</p>
    <p style="margin-top:20px; opacity:0.8;">Click this message to dismiss it</p>
  </div>
</div>

<!-- Viewer -->
<div id="viewer"></div>

<!-- Footer Bar -->
<div id="footerBar">
  Images and Webpage (C) 2025 _______. Do not distribute or modify my content.
</div>

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
let scene, camera, renderer, sphereMesh;
let imageList = [];
let currentIndex = 0;
let isPointerDown = false;
let lastX = 0, lastY = 0;

const viewer = document.getElementById("viewer");

init();
loadImagesFromIMG();
animate();

function init() {
  renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  viewer.appendChild(renderer.domElement);

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
  camera.position.set(0,0,0.01);

  const geo = new THREE.SphereGeometry(500,64,32);
  geo.scale(-1,1,1);
  sphereMesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color:0x111111 }));
  scene.add(sphereMesh);

  window.addEventListener("resize", onResize);
  renderer.domElement.addEventListener("pointerdown", onPointerDown);
  window.addEventListener("pointermove", onPointerMove);
  window.addEventListener("pointerup", ()=>isPointerDown=false);
  renderer.domElement.addEventListener("wheel", onWheel, { passive:false });

  document.getElementById("helpOverlay").addEventListener("click", e=>{
    e.target.style.display="none";
  });

  document.body.classList.add("desktop");

  document.addEventListener("mousemove", e => {
    const w = window.innerWidth;
    if (e.clientX < w * 0.2) {
      document.body.classList.add("hover-left");
      document.body.classList.remove("hover-right");
    } else if (e.clientX > w * 0.8) {
      document.body.classList.add("hover-right");
      document.body.classList.remove("hover-left");
    } else {
      document.body.classList.remove("hover-left");
      document.body.classList.remove("hover-right");
    }
  });

  document.getElementById("nav-left").addEventListener("click", prevImage);
  document.getElementById("nav-right").addEventListener("click", nextImage);

  window.addEventListener("click", e => {
    if (document.getElementById("helpOverlay").style.display !== "none") return;

    const x = e.clientX;
    const w = window.innerWidth;

    if (x < w * 0.10) prevImage();
    else if (x > w * 0.90) nextImage();
  });
}

async function loadImagesFromIMG() {
  try {
    const resp = await fetch("./IMG/");
    const text = await resp.text();
    const matches = [...text.matchAll(/href="([^"]+\.(jpg|jpeg|png|webp))"/gi)];
    imageList = matches.map(m => "IMG/" + m[1]);
    if (imageList.length > 0) loadTexture(imageList[0]);
  } catch (err) {
    console.error("Failed to read IMG folder:", err);
  }
}

function loadTexture(url) {
  const loader = new THREE.TextureLoader();
  loader.load(url, tex => {
    tex.minFilter = THREE.LinearFilter;
    sphereMesh.material.map = tex;
    sphereMesh.material.needsUpdate = true;
  });
}

function nextImage() {
  if (!imageList.length) return;
  currentIndex = (currentIndex + 1) % imageList.length;
  loadTexture(imageList[currentIndex]);
}

function prevImage() {
  if (!imageList.length) return;
  currentIndex = (currentIndex - 1 + imageList.length) % imageList.length;
  loadTexture(imageList[currentIndex]);
}

function onPointerDown(e) {
  isPointerDown = true;
  lastX = e.clientX;
  lastY = e.clientY;
}

function onPointerMove(e) {
  if (!isPointerDown) return;
  const dx = e.clientX - lastX;
  const dy = e.clientY - lastY;
  lastX = e.clientX;
  lastY = e.clientY;
  sphereMesh.rotation.y += dx * 0.005;
  sphereMesh.rotation.x += dy * 0.005;
  const limit = Math.PI/2 - 0.01;
  sphereMesh.rotation.x = Math.max(-limit, Math.min(limit, sphereMesh.rotation.x));
}

function onWheel(e) {
  e.preventDefault();
  camera.fov += e.deltaY * 0.03;
  camera.fov = Math.max(30, Math.min(100, camera.fov));
  camera.updateProjectionMatrix();
}

function onResize() {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
</script>

</body>
</html>
