<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>360 Sphere Viewer</title>

<style>
html,body { margin:0; height:100%; overflow:hidden; background:#000; font-family:system-ui; }

/* --- NAV BUTTONS (Desktop Hover) --- */
.nav-btn {
  position: fixed;
  top: 50%;
  transform: translateY(-50%);
  width: 60px;
  height: 60px;
  border-radius: 14px;
  display: flex;
  align-items:center;
  justify-content:center;
  font-size: 32px;
  color: white;
  backdrop-filter: blur(12px);
  background: rgba(255,255,255,0.18);
  border: 1px solid rgba(255,255,255,0.25);
  cursor: pointer;
  opacity: 0;
  transition: opacity 0.2s;
  z-index: 20;
}
#nav-left { left: 20px; }
#nav-right { right: 20px; }

/* Only show arrows when mouse is inside viewer */
body.desktop.hover-left #nav-left,
body.desktop.hover-right #nav-right {
  opacity: 1;
}

/* --- HELP OVERLAY --- */
#helpOverlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.7);
  color: white;
  display: flex;
  align-items:center;
  justify-content:center;
  text-align:center;
  padding:20px;
  z-index: 50;
  font-size: 18px;
  line-height: 1.4;
}

/* --- Canvas Container --- */
#viewer {
  width:100%;
  height:100%;
}
</style>
</head>

<body>

<!-- Navigation Buttons -->
<div id="nav-left" class="nav-btn">&#10094;</div>
<div id="nav-right" class="nav-btn">&#10095;</div>

<!-- Help Overlay -->
<div id="helpOverlay">
  <div>
    <p><b>Controls</b></p>
    <p>• Drag to rotate the sphere</p>
    <p>• Pinch or mouse wheel to zoom</p>
    <p>• Click left/right screen edges (or tap on mobile) to switch images</p>
    <p style="margin-top:20px; opacity:0.8;">Click this message to dismiss it</p>
  </div>
</div>

<!-- 3D Viewer -->
<div id="viewer"></div>

<!-- THREE JS -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
/* ------------------------------
   GLOBALS
--------------------------------*/
let scene, camera, renderer, sphereMesh;
let imageList = [];
let currentIndex = 0;
let isPointerDown = false;
let lastX = 0, lastY = 0;

const viewer = document.getElementById("viewer");

/* ------------------------------
   INIT
--------------------------------*/
init();
loadImagesFromIMG();
animate();

function init() {
  renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  viewer.appendChild(renderer.domElement);

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
  camera.position.set(0,0,0.01);

  const geo = new THREE.SphereGeometry(500,64,32);
  geo.scale(-1,1,1);
  sphereMesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color:0x111111 }));
  scene.add(sphereMesh);

  window.addEventListener("resize", onResize);
  renderer.domElement.addEventListener("pointerdown", onPointerDown);
  window.addEventListener("pointermove", onPointerMove);
  window.addEventListener("pointerup", onPointerUp);
  renderer.domElement.addEventListener("wheel", onWheel, { passive:false });

  document.getElementById("helpOverlay").addEventListener("click", e=>{
    e.target.style.display="none";
  });

  /* Desktop hover detection */
  document.body.classList.add("desktop");
  document.addEventListener("mousemove", e => {
    const w = window.innerWidth;
    if (e.clientX < w * 0.2) {
      document.body.classList.add("hover-left");
      document.body.classList.remove("hover-right");
    } else if (e.clientX > w * 0.8) {
      document.body.classList.add("hover-right");
      document.body.classList.remove("hover-left");
    } else {
      document.body.classList.remove("hover-left");
      document.body.classList.remove("hover-right");
    }
  });

  /* Nav buttons click */
  document.getElementById("nav-left").addEventListener("click", prevImage);
  document.getElementById("nav-right").addEventListener("click", nextImage);

  /* Mobile tap zones */
  window.addEventListener("click", e => {
    const w = window.innerWidth;
    const x = e.clientX;

    if (document.getElementById("helpOverlay").style.display !== "none") return;

    if (x < w * 0.10) prevImage();
    else if (x > w * 0.90) nextImage();
  });
}

/* ------------------------------
   LOAD IMAGES FROM ./IMG
--------------------------------*/
async function loadImagesFromIMG() {
  try {
    const resp = await fetch("./IMG/");
    const text = await resp.text();
    const matches = [...text.matchAll(/href="([^"]+\.(jpg|jpeg|png|webp))"/gi)];

    imageList = matches.map(m => "IMG/" + m[1]);

    if (imageList.length === 0) {
      console.warn("No images found in IMG/");
      return;
    }

    loadTexture(imageList[0]);

  } catch (err) {
    console.error("Failed to read IMG folder:", err);
  }
}

/* ------------------------------
   LOAD PANORAMA
--------------------------------*/
function loadTexture(url) {
  const loader = new THREE.TextureLoader();
  loader.load(url, tex => {
    tex.minFilter = THREE.LinearFilter;
    sphereMesh.material.map = tex;
    sphereMesh.material.needsUpdate = true;
  });
}

/* ------------------------------
   IMAGE NAVIGATION
--------------------------------*/
function nextImage() {
  if (imageList.length === 0) return;
  currentIndex = (currentIndex + 1) % imageList.length;
  loadTexture(imageList[currentIndex]);
}

function prevImage() {
  if (imageList.length === 0) return;
  currentIndex = (currentIndex - 1 + imageList.length) % imageList.length;
  loadTexture(imageList[currentIndex]);
}

/* ------------------------------
   POINTER / ZOOM CONTROLS
--------------------------------*/
function onPointerDown(e) {
  isPointerDown = true;
  lastX = e.clientX;
  lastY = e.clientY;
}

function onPointerMove(e) {
  if (!isPointerDown) return;

  const dx = e.clientX - lastX;
  const dy = e.clientY - lastY;

  lastX = e.clientX;
  lastY = e.clientY;

  sphereMesh.rotation.y += dx * 0.005;
  sphereMesh.rotation.x += dy * 0.005;

  const limit = Math.PI/2 - 0.01;
  sphereMesh.rotation.x = Math.max(-limit, Math.min(limit, sphereMesh.rotation.x));
}

function onPointerUp() { isPointerDown = false; }

function onWheel(e) {
  e.preventDefault();
  camera.fov += e.deltaY * 0.03;
  camera.fov = Math.max(30, Math.min(100, camera.fov));
  camera.updateProjectionMatrix();
}

/* ------------------------------ */
function onResize() {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

/* ------------------------------ */
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
</script>
</body>
</html>
